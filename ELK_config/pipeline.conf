input {
  beats {
    port => 5044
    host => "0.0.0.0"
  }
}

filter {
  # Extraction universelle de auth_step (authenticationStep)
  grok {
    match => {
      "message" => [
        "transactionInfo/authenticationStep':'%{DATA:auth_step}(,|})",
        "'authenticationStep':'%{DATA:auth_step}'",
        '"authenticationStep":"%{DATA:auth_step}"',
        "authenticationStep[\"']?:[\"']?%{DATA:auth_step}[\"']?(,|})"
      ]
    }
    tag_on_failure => []
  }
  if [auth_step] {
    mutate {
      gsub => [
        "auth_step", "['\"} ]+$", ""
      ]
      strip => ["auth_step"]
    }
  }

  # 1. Essayer de parser le message comme JSON natif
  json {
    source => "message"
    target => "parsed"
    skip_on_invalid_json => true
  }

  # 2. Extraction directe du responseTime, operationCode pour les logs clé/valeur
  grok {
    match => {
      "message" => [
        "transactionDetail/responseTime':'%{NUMBER:response_time}",
        "transactionDetail/operationCode':'%{DATA:operation_code}"
      ]
    }
    tag_on_failure => []
  }

  # Copier les champs plats vers objets imbriqués si besoin
  if [parsed]["transactionDetail/responseTime"] {
    mutate {
      add_field => { "[parsed][transactionDetail][responseTime]" => "%{[parsed][transactionDetail/responseTime]}" }
    }
  }
  if [parsed]["transactionDetail/operationCode"] {
    mutate {
      add_field => { "[parsed][transactionDetail][operationCode]" => "%{[parsed][transactionDetail/operationCode]}" }
    }
  }
  if [parsed]["transactionDetail/operationDescription"] {
    mutate {
      add_field => { "[parsed][transactionDetail][operationDescription]" => "%{[parsed][transactionDetail/operationDescription]}" }
    }
  }
  if [parsed]["transactionInfo/authenticationStep"] {
    mutate {
      add_field => { "[parsed][transactionInfo][authenticationStep]" => "%{[parsed][transactionInfo/authenticationStep]}" }
    }
  }
  if [parsed]["transactionInfo/transactionID"] {
    mutate {
      add_field => { "[parsed][transactionInfo][transactionID]" => "%{[parsed][transactionInfo][transactionID]}" }
    }
  }
  if [parsed]["transactionInfo/bank"] {
    mutate {
      add_field => { "[parsed][transactionInfo][bank]" => "%{[parsed][transactionInfo][bank]}" }
    }
  }
  if [parsed]["transactionInfo/product"] {
    mutate {
      add_field => { "[parsed][transactionInfo][product]" => "%{[parsed][transactionInfo][product]}" }
    }
  }

  # 3. Si le parsing JSON a échoué, utiliser grok
  if ![parsed] {
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp}\s+%{LOGLEVEL:log_level}\s+%{DATA:logger}\s+-\s+\[%{UUID:transaction_id}\]\s+\t?%{GREEDYDATA:json_message}"
      }
      tag_on_failure => ["_grokparsefailure"]
    }
    # Si grok échoue, on prend tout le message comme json_message
    if "_grokparsefailure" in [tags] {
      mutate {
        add_field => { "json_message" => "%{message}" }
      }
    }
    # Remplacer les apostrophes par des guillemets pour simuler du JSON
    mutate {
      gsub => [
        "json_message", "'", "\"",
        "json_message", "\\\"", "\"",
        "json_message", "\\n", "",
        "json_message", "\\t", "",
        "json_message", "\\u003d", "="
      ]
    }
    # Tenter de parser le json_message
    json {
      source => "json_message"
      target => "parsed"
      skip_on_invalid_json => true
      remove_field => ["json_message"]
    }
    # Copier les champs plats vers objets imbriqués si besoin (après parsing json_message)
    if [parsed]["transactionDetail/responseTime"] {
      mutate {
        add_field => { "[parsed][transactionDetail][responseTime]" => "%{[parsed][transactionDetail/responseTime]}" }
      }
    }
    if [parsed]["transactionDetail/operationCode"] {
      mutate {
        add_field => { "[parsed][transactionDetail][operationCode]" => "%{[parsed][transactionDetail/operationCode]}" }
      }
    }
    if [parsed]["transactionDetail/operationDescription"] {
      mutate {
        add_field => { "[parsed][transactionDetail][operationDescription]" => "%{[parsed][transactionDetail/operationDescription]}" }
      }
    }
    if [parsed]["transactionInfo/authenticationStep"] {
      mutate {
        add_field => { "[parsed][transactionInfo][authenticationStep]" => "%{[parsed][transactionInfo][authenticationStep]}" }
      }
    }
    if [parsed]["transactionInfo/transactionID"] {
      mutate {
        add_field => { "[parsed][transactionInfo][transactionID]" => "%{[parsed][transactionInfo][transactionID]}" }
      }
    }
    if [parsed]["transactionInfo/bank"] {
      mutate {
        add_field => { "[parsed][transactionInfo][bank]" => "%{[parsed][transactionInfo][bank]}" }
      }
    }
    if [parsed]["transactionInfo/product"] {
      mutate {
        add_field => { "[parsed][transactionInfo][product]" => "%{[parsed][transactionInfo][product]}" }
      }
    }
  }

  if [parsed][transactionInfo][authenticationStep] {
    mutate {
      add_field => {
        "auth_step" => "%{[parsed][transactionInfo][authenticationStep]}"
        "transaction_id" => "%{[parsed][transactionInfo][transactionID]}"
        "bank" => "%{[parsed][transactionInfo][bank]}"
        "product" => "%{[parsed][transactionInfo][product]}"
      }
    }
  }

  if [parsed][transactionDetail][operationCode] {
    mutate {
      add_field => {
        "response_time" => "%{[parsed][transactionDetail][responseTime]}"
        "operation_code" => "%{[parsed][transactionDetail][operationCode]}"
        "operation_desc" => "%{[parsed][transactionDetail][operationDescription]}"
      }
    }
    if ![response_time] or [response_time] == "" {
      mutate {
        add_field => { "response_time" => 0 }
      }
    }
    mutate {
      convert => {
        "response_time" => "integer"
      }
    }
  }

  if [parsed]["transactionDetail/request"] {
    mutate {
      gsub => [
        "[parsed][transactionDetail/request]", "\\\"", "\""
      ]
    }
    json {
      source => "[parsed][transactionDetail/request]"
      target => "request_details"
      skip_on_invalid_json => true
    }
  }
  if [parsed]["transactionDetail/response"] {
    mutate {
      gsub => [
        "[parsed][transactionDetail/response]", "\\\"", "\""
      ]
    }
    json {
      source => "[parsed][transactionDetail/response]"
      target => "response_details"
      skip_on_invalid_json => true
    }
  }
  if [parsed][transactionDetail][request] {
    mutate {
      gsub => [
        "[parsed][transactionDetail][request]", "\\\"", "\""
      ]
    }
    json {
      source => "[parsed][transactionDetail][request]"
      target => "request_details"
      skip_on_invalid_json => true
    }
  }
  if [parsed][transactionDetail][response] {
    mutate {
      gsub => [
        "[parsed][transactionDetail][response]", "\\\"", "\""
      ]
    }
    json {
      source => "[parsed][transactionDetail][response]"
      target => "response_details"
      skip_on_invalid_json => true
    }
  }

  if [operation_code] in ["TIME_OUT", "NOT_AUTHENTICATED"] or [response_details][transStatus] == "N" {
    mutate {
      add_field => {
        "is_error" => true
        "error_type" => "%{[operation_code]}"
      }
    }
  } else {
    mutate {
      add_field => { "is_error" => false }
    }
  }

  # Forcer la présence de response_time même si parsing échoue
  if ![response_time] {
    mutate {
      add_field => { "response_time" => 0 }
    }
  }
  mutate {
    convert => { "response_time" => "integer" }
  }

  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
  }

  # Agrégation pour calculer les différences de temps par transaction_id
  # Assumant que les événements arrivent dans l'ordre chronologique
aggregate {
    task_id => "%{transaction_id}"
    code => "
      # Initialisation
      map['steps'] ||= {}
      step = event.get('auth_step')
      timestamp = event.get('@timestamp').to_f

      if step
        # Enregistre le timestamp pour cette étape
        map['steps'][step] = timestamp

        # Calcul des durées (fonctionne même si les événements arrivent dans le désordre)
        if map['steps']['ARES_SENDING'] && map['steps']['CREQ_RECEPTION']
          duration = (map['steps']['CREQ_RECEPTION'] - map['steps']['ARES_SENDING']) * 1000
          event.set('CREQ_RECEPTION_ms', duration.round(2))
        end

        if map['steps']['CREQ_RECEPTION'] && map['steps']['CHALLENGE_DISPLAY']
          duration = (map['steps']['CHALLENGE_DISPLAY'] - map['steps']['CREQ_RECEPTION']) * 1000
          event.set('CHALLENGE_DISPLAY_ms', duration.round(2))
        end
         
        if map['steps']['AUTH_VALIDATION'] && map['steps']['RREQ_SENDING']
          duration = (map['steps']['RREQ_SENDING'] - map['steps']['AUTH_VALIDATION']) * 1000
          event.set('RREQ_SENDING_ms', duration.round(2))
    end

        # Debug (à vérifier dans les logs)
        event.tag('aggregate_processed')
      end
    "
    push_previous_map_as_event => false
    timeout => 600 # 10 minutes
    timeout_tags => ['aggregate_timeout']
  }

  mutate {
    remove_field => ["parsed", "host", "agent", "input", "ecs", "log", "beat", "json_message"]
  }
}

output {
  elasticsearch {
    hosts => ["http://localhost:9200"]
    index => "transactions-%{+YYYY.MM.dd}"
    user => "elastic"
    password => "0RM69TWf5_Nn_xOFWSdm"
    ssl => false
    template => "C:/temp/template.json"
    template_name => "transactions-template"
  }
  stdout { codec => rubydebug }
}